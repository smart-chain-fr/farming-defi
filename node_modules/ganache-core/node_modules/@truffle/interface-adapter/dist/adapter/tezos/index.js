"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const taquito_1 = require("@taquito/taquito");
class TezosAdapter {
    constructor({ provider, config }) {
        this.tezos = taquito_1.Tezos;
        this.setProvider({ provider, config });
    }
    getNetworkId() {
        return __awaiter(this, void 0, void 0, function* () {
            const { chain_id } = yield this.tezos.rpc.getBlockHeader();
            return chain_id;
        });
    }
    getBlock(blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            // translate ETH nomenclature to XTZ
            if (blockNumber === "latest")
                blockNumber = "head";
            const { hard_gas_limit_per_block } = yield this.tezos.rpc.getConstants();
            const block = yield this.tezos.rpc.getBlockHeader({
                block: `${blockNumber}`
            });
            // @ts-ignore: Property 'gasLimit' does not exist on type 'BlockHeaderResponse'.
            block.gasLimit = hard_gas_limit_per_block;
            return block;
        });
    }
    getTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            //  return this.web3.eth.getTransaction(tx);
            return;
        });
    }
    getTransactionReceipt(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            //  return this.web3.eth.getTransactionReceipt(tx);
            return;
        });
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const balance = (yield this.tezos.tz.getBalance(address)).toString();
            return balance;
        });
    }
    getCode(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const storage = yield this.tezos.contract.getStorage(address);
            return storage;
        });
    }
    getAccounts(config) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setWallet(config);
            const currentAccount = yield this.tezos.signer.publicKeyHash();
            return [currentAccount];
        });
    }
    estimateGas(transactionConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            //    return this.web3.eth.estimateGas(transactionConfig);
            return 0;
        });
    }
    getBlockNumber() {
        return __awaiter(this, void 0, void 0, function* () {
            const { level } = yield this.tezos.rpc.getBlockHeader();
            return level;
        });
    }
    setProvider({ provider, config = { confirmationPollingIntervalSecond: 1 } }) {
        // @ts-ignore: Property 'host' does not exist on type 'Provider'.
        const { host } = provider;
        let currentHost;
        if (host) {
            currentHost = host;
        }
        else {
            currentHost = provider;
        }
        return this.tezos.setProvider({ rpc: currentHost, config });
    }
    setWallet(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const { networks, network } = config;
            let { mnemonic, secretKey } = networks[network];
            if (network === "test" && networks.test.develop) {
                secretKey = `edsk3QoqBuvdamxouPhin7swCvkQNgq4jP5KZPbwWNnwdZpSpJiEbq`;
            }
            if (mnemonic) {
                // here we import user's faucet account:
                // email, password, mnemonic, & secret are all REQUIRED.
                if (Array.isArray(mnemonic))
                    mnemonic = mnemonic.join(" ");
                try {
                    return yield this.tezos.importKey(networks[network].email, networks[network].password, mnemonic, networks[network].secret);
                }
                catch (error) {
                    throw Error(`Faucet account invalid or incorrectly imported in truffle config file (config.networks[${network}]).`);
                }
            }
            if (secretKey) {
                try {
                    return yield this.tezos.importKey(secretKey);
                }
                catch (error) {
                    throw Error(`Secret key invalid or incorrectly imported in truffle config file (config.networks[${network}].secretKey).`);
                }
            }
            // TODO: add logic to check if user is importing a psk w/ password
            throw Error(`No faucet account or secret key detected in truffle config file (config.networks[${network}]).`);
        });
    }
}
exports.TezosAdapter = TezosAdapter;
//# sourceMappingURL=index.js.map